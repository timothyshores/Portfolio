---
title: "Using JSON Web Tokens (JWT)"
date: "2019-05-08"
---

##Saving Cookies to the Database using connect-session-knex

*Issue: When we restart the server the cookies are deleted*

*Solution: We want cookies to persist to the database rather than in temporary server memory*

**Initial Repo: https://github.com/timothyshores/webauth-ii-guided/tree/0b796492ccac33ed18fb8f7f9e193a3fefaa8301**


1. Install connect-session-knex via yarn 
   - Run `yarn add connect-session-knex` in terminal
2.  Use a higher order component (HOC) to import connect-session-knex and pass in session into `server.js` 

```javascript
const KnexSessionStore = require('connect-session-knex')(session);
```

3. Update sessionConfig object to include a key of store with the keys knex, createtable, clearInterval

```javascript
const sessionConfig = {
    // default value is session id
    name: 'name of the cookie', 

    // only our server knows this value for production store this in .env file
    secret: 'keep it secret, keep it safe - gandalf', 

    cookie: {
        // true prevents access from Javascript console in the user's browser
        httpOnly: true, 

        // value in miliseconds so 1000 * 60 * 10 is ten minutes
        maxAge: 1000 * 60 * 10, 

        // false allows cookies to be sent via http and true allows cookies to be sent via https
        secure: false, 
    },
    // false prevents a cookie from automatically being generated by the server
    resave: false, 
    
    // create new session automatically, display to client that the website stores cookies
    saveUninitialized: true, 
    
    store: new KnexSessionStore({
        knex: require('../database/dbConfig.js'),
        createtable: true,
        clearInternal: 1000 * 60 * 15, // 15 minute session
    })
};
```

---

##JSON Web Tokens (JWT) with Auth0

**Cookies vs JSON Web Tokens (JWT)**

**Initial Repo: https://github.com/LambdaSchool/webauth-iii-guided**

Similarities: Different ways of keeping track of which users are currently logged in.

Differences: Cookies are held by the server while tokens are held by the client


1.  Install `dotenv` by running `yarn add dotenv`
2.  Import `dotenv` into `index.js`

```javascript
require("dotenv").config();
```
3.  Create a .env file in the root directory of the project
4.  Create a variable called `JWT_SECRET` and set it equal to 

```javascript
JWT_SECRET=this is the secret key
```

5. Install `jsonwebtoken` by running `yarn add jsonwebtoken` in terminal
6. Import `jsonwebtoken` into `auth/auth-router.js` 

```javascript
const jwt = require('jsonwebtoken');
```

7. Create a function called generateToken and pass in a user in `auth/auth-router.js`

```javascript
function generateToken(user) {
    const payload = {
        subject: user.id,
        username: user.username,
    };
    const secret = 'secret string to store in .env file before production'
    const options = {
        expiresIn: '1h'
    }
    return jwt.sign(payload, process.env.JWT_SECRET, options)
}
```

8.  Update POST request endpoint to /api/login to generate a new token after the username and password match in the Users table. 
    
*Note: We are using bcryptjs to match the unhashed password that the user enters to the hashed password stored in S* 

```javascript
router.post('/login', (req, res) => {
    let { username, password } = req.body;

    Users.findBy({ username })
        .first()
        .then(user => {
            if (user && bcrypt.compareSync(password, user.password)) {
                const token = generateToken(user);
                res.status(200).json({
                    message: `Welcome ${user.username}!`,
                    token,
                });
            } else {
                res.status(401).json({ message: 'Invalid Credentials' });
            }
        })
        .catch(error => {
            res.status(500).json(error);
        });
});
```

9. Refactor `auth/middleware.js` to check for JWT rather than use brcyptjs to compare the user's unhashed password with the hashed password in the database

```javascript
const jwt = require('jsonwebtoken');
const secrets = require('../config/secrets');

module.exports = (req, res, next) => {
    const token = req.headers.authorization;

    jwt.verify(token, secrets.jwtSecret, (err, decodedToken) => {
        if (err) {
            // token is invalid, expired or modified
            res.status(401).json({ error: "Invalid token" })
        } else {
            // token is valid
            req.decodedToken = decodedToken;
            next();
        }
    });
};
```

10. Import `auth/middleware.js` into `users/users-router.js` and add middleware

```javascript
const restricted = require('../auth/restricted-middleware.js');

router.get('/', restricted, (req, res) => {
    Users.find()
        .then(users => {
            res.json(users);
        })
        .catch(err => res.send(err));
});
```

11. Create a `checkRole(role)` function in `users/users-router.js` that restricts the ability to view a list of users based on their role

```javascript
function checkRole(role) {
    return function (req, res, next) {
        (req.decodedToken.roles && req.decodedToken.roles.includes(role))
            ? next();
            : res.status(403).json({ message: "Unable to access users" })
    }
}
```

12. Apply the checkRole middleware to our GET `/api/users` endpoint

```javascript
router.get('/', restricted, checkRole('student'), (req, res) => {
    Users.find()
        .then(users => {
            res.json(users);
        })
        .catch(err => res.send(err));
});
```

**Final Repo: https://github.com/timothyshores/webauth-iii-guided**